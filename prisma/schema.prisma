// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Better Auth tables
model User {
  id            String       @id @default(cuid())
  name          String?
  email         String?      @unique
  emailVerified Boolean      @default(false)
  image         String?
  walletAddress String?      @unique // Endereço da carteira XRPL (Crossmark)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  accounts      Account[]
  sessions      Session[]
  investments   Investment[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Investment models
model InvestmentProject {
  id           String        @id @default(cuid())
  name         String // LAND-MPT, BUILD-MPT, REV-MPT, COL-MPT
  type         String // LAND, BUILD, REV, COL
  description  String?
  purpose      String // Propósito do token
  example      String? // Exemplo de uso
  minAmount    Float         @default(0) // Valor mínimo de investimento
  maxAmount    Float? // Valor máximo de investimento
  totalAmount  Float         @default(0) // Total arrecadado
  targetAmount Float // Meta de arrecadação
  status       String        @default("active") // active, completed, paused
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  investments  Investment[]
  files        ProjectFile[]
}

model ProjectFile {
  id          String            @id @default(cuid())
  projectId   String
  fileName    String // Nome original do arquivo
  filePath    String // Caminho do arquivo no servidor
  fileType    String // Tipo MIME (application/pdf, etc)
  fileSize    Int // Tamanho em bytes
  description String? // Descrição opcional do arquivo
  uploadedBy  String? // ID do usuário que fez upload (opcional)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  project     InvestmentProject @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId])
  @@index([createdAt])
}

model Investment {
  id        String            @id @default(cuid())
  userId    String
  projectId String
  amount    Float // Valor em R$
  xrpAmount Float? // Valor em XRP enviado
  txHash    String?           @unique // Hash da transação XRP (único para idempotência)
  status    String            @default("pending") // pending, confirmed, published, denied, cancelled
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  user      User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  project   InvestmentProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

model RevPayoutBatch {
  id           String          @id @default(cuid())
  tokenId      String
  stablecoinId String
  network      String
  totalAmount  Float
  memo         String?
  scheduledFor DateTime?
  status       String          @default("scheduled") // scheduled, processing, completed, error, cancelled
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  items        RevPayoutItem[]
}

model RevPayoutItem {
  id            String         @id @default(cuid())
  batchId       String
  holderAddress String
  holderBalance Float
  share         Float
  amount        Float
  status        String         @default("pending") // pending, processing, paid, error, skipped, trustline_missing
  attempts      Int            @default(0)
  txHash        String?
  lastError     String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  batch         RevPayoutBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@index([batchId])
  @@index([status])
}

// Elysia logs - Migrado de memória para banco
model IssuanceRecord {
  id          String   @id @default(cuid())
  projectId   String
  projectName String
  tokenType   String
  currency    String
  amount      String   @db.Text
  decimals    Int
  issuer      String
  network     String
  txHash      String
  metadata    Json     @default("{}")
  rawResponse Json?
  createdAt   DateTime @default(now())

  @@index([projectId])
  @@index([issuer])
  @@index([txHash])
  @@index([createdAt])
}

model ActionRecord {
  id            String   @id @default(cuid())
  type          String // authorize, payment, freeze, clawback, payout, error, trustset
  tokenCurrency String
  tokenIssuer   String
  actor         String
  target        String?
  amount        String?  @db.Text
  network       String
  txHash        String
  metadata      Json     @default("{}")
  createdAt     DateTime @default(now())

  @@index([type])
  @@index([actor])
  @@index([txHash])
  @@index([createdAt])
  @@index([tokenCurrency, tokenIssuer])
}

// Auditoria de flags e permissões
model FlagAudit {
  id               String   @id @default(cuid())
  operation        String // freeze, clawback, authorize
  tokenCurrency    String
  tokenIssuer      String
  executor         String // Wallet que executou a operação
  target           String? // Wallet alvo (holder)
  amount           String?  @db.Text
  network          String
  txHash           String
  // Informações de auditoria
  sourceIP         String?
  userAgent        String?
  regularKeyUsed   Boolean  @default(false) // Se foi executado via RegularKey
  coldWallet       String? // Wallet cold (issuer principal)
  hotWallet        String? // Wallet hot (RegularKey, se usado)
  // Permissões verificadas
  hadPermission    Boolean  @default(true)
  permissionReason String? // Razão se não tinha permissão
  metadata         Json     @default("{}")
  createdAt        DateTime @default(now())

  @@index([operation])
  @@index([executor])
  @@index([tokenIssuer])
  @@index([txHash])
  @@index([createdAt])
  @@index([tokenCurrency, tokenIssuer])
}

// Configuração de permissões por issuer
model IssuerPermission {
  id                           String   @id @default(cuid())
  issuer                       String // Wallet issuer
  network                      String
  // Permissões por operação
  canFreeze                    Boolean  @default(false)
  canClawback                  Boolean  @default(false)
  canAuthorize                 Boolean  @default(true) // Autorizar é mais comum
  // Wallets autorizadas
  authorizedWallets            String[] // Lista de wallets que podem executar operações
  // RegularKey configurada
  regularKey                   String? // Wallet hot (RegularKey)
  coldWallet                   String // Wallet cold (issuer principal)
  // Configurações
  requireColdWalletForFreeze   Boolean  @default(true)
  requireColdWalletForClawback Boolean  @default(true)
  metadata                     Json     @default("{}")
  createdAt                    DateTime @default(now())
  updatedAt                    DateTime @updatedAt

  @@unique([issuer, network])
  @@index([issuer])
  @@index([network])
}

model ServiceWallet {
  id            String   @id @default(cuid())
  label         String
  document      String?
  type          String   @default("issuer") // ISSUER | DISTRIBUTION | USER_INTERNAL | USER_EXTERNAL
  network       String   @default("testnet")
  address       String   @unique
  publicKey     String?
  seedEncrypted String
  isActive      Boolean  @default(false)
  userId        String? // Para carteiras de usuário (USER_INTERNAL)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relações
  issuedMPTs       MPTIssuance[]      @relation("IssuerWallet")
  distributionMPTs MPTIssuance[]      @relation("DistributionWallet")
  authorizations   MPTAuthorization[]

  @@index([type, isActive])
  @@index([userId])
}

// Purchase Flow - Compra Primária com Idempotência
model Purchase {
  id             String        @id @default(cuid())
  purchaseId     String        @unique // Chave idempotente externa
  userId         String
  projectId      String?
  amount         Float
  currency       String
  status         String        @default("PENDING") // PENDING, FUNDS_CONFIRMED, MPT_SENT, COMPLETED, FAILED, COMPENSATION_REQUIRED, ACTION_REQUIRED
  mptCurrency    String?
  mptAmount      String?
  mptIssuer      String?
  fundsTxHash    String?       @unique
  mptTxHash      String?
  retryCount     Int           @default(0)
  lastError      String?       @db.Text
  engineResult   String?
  compensationId String?
  actionRequired String? // RequireAuth, Trustline, etc.
  lockedAt       DateTime?
  lockedBy       String?
  metadata       Json          @default("{}")
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  compensation   Compensation?

  @@index([purchaseId])
  @@index([status])
  @@index([fundsTxHash])
  @@index([mptTxHash])
  @@index([userId])
  @@index([createdAt])
}

// Compensação
model Compensation {
  id             String    @id @default(cuid())
  purchaseId     String    @unique
  type           String // REFUND, RETRY_MPT, MANUAL
  status         String    @default("PENDING") // PENDING, APPROVED, EXECUTED, FAILED
  reason         String    @db.Text
  approvedBy     String?
  approvedAt     DateTime?
  executedAt     DateTime?
  refundTxHash   String?
  retryMptTxHash String?
  metadata       Json      @default("{}")
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  purchase       Purchase? @relation(fields: [purchaseId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([purchaseId])
}

// Circuit Breaker State
model CircuitBreakerState {
  id           String    @id @default(cuid())
  endpoint     String    @unique
  state        String    @default("CLOSED") // CLOSED, OPEN, HALF_OPEN
  failureCount Int       @default(0)
  lastFailure  DateTime?
  openedAt     DateTime?
  nextAttempt  DateTime?
  metadata     Json      @default("{}")
  updatedAt    DateTime  @updatedAt

  @@index([state])
}

// MPT Issuances - Emissões de Multi-Purpose Tokens
model MPTIssuance {
  id            String @id @default(cuid())
  type          String // LAND | BUILD | REV | COL
  symbol        String // Ex: "LAND-ITA-001"
  name          String // Ex: "Viverde Itaipu LAND"
  maximumAmount String @db.Text // Quantidade máxima (string para precisão)
  decimals      Int    @default(0)
  assetScale    Int    @default(0)
  transferFee   Int    @default(0) // Basis points (0-50000)

  // Wallets
  issuerWalletId       String
  distributionWalletId String?

  // XRPL On-chain
  xrplIssuanceId String? @unique // MPTokenIssuanceID (hex)
  xrplCurrency   String? // Currency gerado automaticamente pelo XRPL
  issuanceTxHash String? @unique

  // Metadata
  metadataJson Json @default("{}")
  flags        Json @default("{}") // Flags do MPT

  // Estado
  network String @default("testnet")
  status  String @default("CREATED") // CREATED | MINTED | ACTIVE | PAUSED

  // Supply tracking
  totalMinted         String @default("0") @db.Text
  distributionBalance String @default("0") @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relações
  issuerWallet       ServiceWallet      @relation("IssuerWallet", fields: [issuerWalletId], references: [id])
  distributionWallet ServiceWallet?     @relation("DistributionWallet", fields: [distributionWalletId], references: [id])
  authorizations     MPTAuthorization[]

  @@index([type])
  @@index([symbol])
  @@index([issuerWalletId])
  @@index([distributionWalletId])
  @@index([xrplIssuanceId])
  @@index([status])
  @@index([network])
}

// MPT Authorizations - Autorizações para receber MPT
model MPTAuthorization {
  id                     String   @id @default(cuid())
  issuanceId             String
  walletId               String? // Para carteiras internas (USER_INTERNAL)
  walletAddress          String // Endereço XRPL (para Crossmark ou internas)
  walletType             String // "crossmark" | "internal"
  status                 String   @default("PENDING") // PENDING | AUTHORIZED | REJECTED
  authorizationTxHash    String?  @unique
  authorizationRequestId String?  @unique // Para rastrear autorizações pendentes do Crossmark
  network                String   @default("testnet")
  metadata               Json     @default("{}")
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  // Relações
  issuance MPTIssuance    @relation(fields: [issuanceId], references: [id], onDelete: Cascade)
  wallet   ServiceWallet? @relation(fields: [walletId], references: [id])

  @@unique([issuanceId, walletAddress]) // Uma autorização por wallet por MPT
  @@index([issuanceId])
  @@index([walletAddress])
  @@index([walletId])
  @@index([status])
  @@index([authorizationRequestId])
}
